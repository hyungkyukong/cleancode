## 동시성 

### 동시성이 필요한 이유? 
* 동시성은 결합을 없애는 전략이다.
* 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다. 
* 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 
* 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라  작은 여러 프로그램 여럿으로 보여 시스템을 이해하기 쉽고  문제를 분리하기도 쉽다. 

예를 들어 서블릿(Servlet)은  웹 또는 EJB 컨테이너라는 곳에서 돌아간다. 이들 컨테이너는 동시성을 부분적으로 관리한다.   

* 웹 요청 들어오면  웹서버는  비동기식으로 서블릿을 실행 
* 서블릿 스레드는 다른 서블릿 스레드와 무관하게 돌아간다. 

* 읍답시간과 작업처리량에 대한 요구상항에서도 유용하게 사용된다 
  * 만약 정보 수지 기능을 단일 스레드로 짠다면 한사이트의 정보를 다 가지고 오고 한 사이트가 끝나야 다음 사이트로 이동해야한다.   
  * 하지만 다중 스데르도 하면 병렬적으로 빠른 시간안에 정보를 수집할 수 있다. 
* 다른 예로는 다중 사용자들이 웹서버 동시 접속, 동시 요청할 때 응답 시간에 관한 부분도 있다. 


### 미신과 오해 
* 동시성으로 만들기는 어렵다. 
* 각별한 주의가 없다면 대형 사고가 생길 수도있다. 

아래는 미신과 오해에 대한 내용들이다. 
* 동시성은 향상 성능을 높여준다. 
  * 대기시간이 길어 여러 스레드가 프로세서를 공유하거나, 여러 프로세서가 어떤 계산을 병렬적으로 처리하는 부분 등에서 향상된 성능을 볼 수 있다.   
  * 위의 상황은 일상적으로 발생하는 상황은 아니다. 
* 동시성을 구현해도 설계는 변하지 않는다. 
  * 단일 / 다중 스레드 시스템 설계는 판이하게 다르다.
  * 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다. 
* 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. 
  * 실제로 동시성이 어떻게 동작하는지..  동시성 수정, 데드락 등과 같은 문제를 어떻게 피할 수 있는지를 알아야한다.

다음은 동시성과 관련된 타당하다고 생각하는 몇가지 이다. 
* 동시성은 다소 부하를 유발한다.
  * 병렬 처리가 많다면 성능면에서 부하가 조금 생기며 코드도 더 짜야한다.
* 동시성윽 복잡하다. 
  * 간단한 문제라도 동시성은 복잡하다. 
* 일반적으로 동시성 버그는 재현하기 어렵다.
* 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

### 난관 
* 동시성을 구현하기 어려운 이유 

```java
public class x {
    private int lastIdUsed;

  public int getNextId() {
      return ++lastIdUsed;
  }
}
```

* 만약 A, B라는 스레드가 있다고 가정할 때 두 스레드가 동시 다발적으로 getNextId()를 요청하면 어떻게 될까? 
* 하나의 변수를 공유하기 때문에 논리적인 오류가 발생한다. 

### 동시성 방어 원칙 
동시성이 일으키는 문제로부터 시스템을 방어하는 원칙과 기술은 아래에 소개하겠다. 

단일책임 원칙(Single Responsibility Principle) SRP
* 메서드, 클래스, 컴포넌트를 변경해야 하는 이유가 하나여야 한다는 원칙이다. 
* 즉 동시성과 관련된 코드는 다른 코드들과 분리해야한다는 의미이다.
  * 동시성을 구현할 때 다음 몇가지를 고려한다.
    * 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
    * 동시성 코드에는 독자적인 난관이있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다. 
    * 잘못 구현한 동시성은 별의별 방식으로 실패를 한다. 

    > 따라서 동시성 코드는 다른 코드와 분리하는것을 권장한다.

따름 정리 corollary : 자료 범위를 제한하라. 
* 위의 내용처럼  하나의 클래스에서 필드를 공동으로 사용하면 문제가 발생한다. 
* 해결 방안으로는 그 객체 코드내에 임계영역 (critical section)을 synchronized 키워드로 보호하라고 권장한다. 
* 이런 임계영역의 수를 줄이는 기술이 중요하다. 
  * 그렇지 않을 경우 아래와 같은 상황이 발생한다. 
  * 보호할 임계영역을 빼먹는다.
  * 모든 임계영역을 올바르게 보호했는지 확인하느라 시간 및 비용이 든다. 
  * 버그 발생 시 더 찾기 어려운 버그가 된다.
  * 그래서 자료를 캡슐화 하여 공유 자료를 최대한 줄이는것을 권장한다. 

* 따름 정리 : 자료 사본을 사용하라. 
 * 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다. 
 * 방법 중 하나로 객체를 복사해서 사용 하는 부분이 있다. 
 * 위와 같은 방법은 에러가 날 확률은 적지만 복사하는데 들어가는 시스템처리 속도나 부하가 문제가 될 수도있다.   
   실측을 하는게 제일 좋지만 에러 발생 후 찾는 노력과 사본을 만드는 노력이 별반 차이 나지 않는 상황이 더 많을것이다. 

* 따름 정리 : 스레드는 가능한 독립적으로 구현하라.
 * 다른 스레드와 자료를 공유하지 않는다. 
 * 모든 정보는 비공유 출처에서 가져오며, 로컬 변수에 저장한다. 
 * 독자전인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하는것을 권장한다. 

### 라이브러리를 이해하라
* 라이브러리에는 동시성을 구현 및 도와주는 API들이 있다. 
* 조금더 안전하고 편의있게 사용 할 수잇다. 

### 실제 모델을 이해하라.

사전 지식으로 전문 용어를 몇자 적어보겠다. 
* 한정된 자원(Bound Resource) : 다중 스레드에서 환경에서 자원으로, 크기나 숫자가 제한적이다.   
데이버 테이스 연결, 길이가 일정한 읽기/쓰기 범퍼 등이 예다
* 상호배제(Mutual Exclusion) : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
* 기아(Starvation) : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.   
예를 들어, 항상 짧은 스레드에게 우선 순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다. 
* 데드락(Deadlock) : 여러 스레드가 서로가 끝나기를 기라딘다. 모든 스레드가 각기 필요한 자원을 을 다른 스레드가 점유 하는 바람에 어느 쪽도 더 이상진행하지 못한다. 
* 라이브락(Livelock) : 락을 거는 단계에서 스레드가 서로 방해를 한다. 스레드는 계속 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 혹은 오랫동안 진행하지 못한다. 


아래는  다중 스레드 프로그래밍에서 사용하는 실행 모델을 몇 가지 살펴보자. 

* 생산자-소비자 Producer-Consumer 
  * 하나 이상의 생산자 스레드가 정보를 생성해 버퍼(buffer)나 대기열(queue)에 넣는다.
  * 하나 이상의 소비자 스레드가 대기열에서 정보를 가져와 사용한다. 
  * 생산자/소비자 스레드가 사용하는 대기열은 *한정된 자원*이다.
  * 생산자/소비자는 대기열에 정보가 없으면/있으면 정보를 채우거나/가져간다 그리고 각 상대 스레드에게 대기열에 대한 상태를 시그널로 알린다.
  * 따라서 잘못하면 생산자/소비자 스레드가 둘 다 진행이 가능하지만 동시에 서로의 시그널을 기다릴 가능성이 존재한다. 
* 읽기-쓰기 Readers-writers 
  * 읽기 스레드는 주된 정보원으로 공유 자원을 사용하지만 쓰기 스레드가 가끔씩 갱신한다고 하자. 
  * 읽기만 하면 처리율이 올라가지만 그러면 쓰기 스레드는 *기아*에 빠질 수 있다. 
  * 읽기 스레드와 쓰기 스레드의 균형잡기가 필요한다.
* 식사하는 철학자들 Dining Philosophers
  * 둥근 식탁에 철학자들이 모여 앉아있다. 각 철학자 왼쪽에는 포크가있고 식탁 가운데에는 스파게티가 있다. 
  * 배가 안고프면 생각에 잠기고, 배고프면 스파게티를 먹는다. 단 양손에 포크를 쥐어야만 먹을 수있다. 
  * 왼쪽 또는 오른쪽 철학자가 포크를 사용중이면 나는 그들이 먹을때까지 기다렸다가 먹어야 한다. 
  * 철학자=스레드 / 포크=자원 으로 바꿔 생각한 알고리즘 
  * 여러 프로세스가 자원을 얻으려고 경쟁한다. 
  * 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다.

> 위의 설명한 기본 알고리즘과 각 해법을 이해하고 직접 구현해보는것을 책에서는 권장한다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
* 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 
* 자바 언어는 syncrhonized 라는 개념을 지원한다.
* 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인하기 바란다. 
  * 권장사항 : 공유 객체 하나에는 메서드 하나만 사용하라.

* 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그럼 다음 세 가지 방법을 고려하라. 
  * 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다. 
  * 서버에서 잠금 : '서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는' 메서드를 구현하고 클라이언트에서 이 메서드를 호출한다. 
  * 연결(Adapted) 서버 : 잠금을 수행하는 중간 단계를 생성한다. '서버에는  잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다. 

### 동기화하는 부분을 작게 만들어라 
* 자바에서 synchronized 키워드를 사용하면 락을 설정한다.
* 같은 락으로 감싼 모든 코드 영역은  한 번에 한 스레드만 실행이 가능하다. 
* 락은 스레드를 지연시키고 부하를 가중시킨다. 따라서 synchronized 문을 남발하는것은 옳지 않다. 
* 반면 임계영역은 반드시 보호해야한다. 따라서 임계영역 수를 최대한 줄여야 한다. 
* 그렇다고 임계영역을 하나로 만들어 덩어리를 키우면 안된다. 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다. 
> 권장사항 : 동기화하는 부분을 최대한 작게 만들어라. 

### 올바른 종료 코드는 구현하기 어렵다. 
* 영구적으로 돌아가게 하는 시스템과 잠시 돌다가 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다. 
* 깔끔하게 종료하는 방식은 어렵다. 흔히 발생하는 문제가 데드락이다. 즉 스레드가 절대 오지 않은 시그널을 기다리는 경우다.
> 예를 들어 부모 스레드가 여러 자식 스레드를 만든 후 끝나기를 기다린다면   
> 그 중 하나의 자식스레드가 데드락이 발생했다면  부모 스레드는 영원히 기다리게 된다. 

> 다른 예로는 사용자가 직접 종료하는 기능을 호출 했을 경우 부모 스레드는 자식 스레드에게 종료하라고 시그널을 보낸다.
> 만약 그중 생산자/소비자 개념의 스레드가 존재한다면 생산자는 바로 종료했지만 소비자는 생산자 시그널을 기다리고   
> 부모 스레드도 자식 스레드를 영원히 기다리는 경우도 있다. 

> 권장사항 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야한다. 생각보다 오래 걸린다.   
> 생각보다 어려우므로 이미 나온 알고리즘을 검토하는 것도 좋은 방법이다. 

### 스레드 코드 테스트하기
* 같은 코드와 같은 자원을 사용하는 스레드가 둘 이상으로 늘어나면 급격하게 복잡해진다.
> 권장사항 : 문제를 노출하는 테스트 케이스를 작성하라.   
> 프로그램 설정, 시스템 설정, 부하 등을 바꿔가며 자주 돌려라.   
> 테스트가 실패하면 원인을 추척하라.

* 위의 권장사항처럼 고려할 사항이 많다. 아래에 몇 가지 구체적인 지침을 제시한다.
  * 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라.
  * 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
  * 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라. 
  * 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조정할 수 있게 작성하라
  * 프로세서 수보다 많은 스레드를 돌려봐라.
  * 다른 플랫폼에서 돌려봐라.
  * 코드에 보조 코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키게 해보라

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
* 다중 스레드는 '말이 안되는' 오류를 가끔 일으킨다. 
* 스레드가 다른 코드와 교류하는 방식을 직관적으로 이해하기는 정말 어렵고 하지 못한다.
* 이런 다중 스레드는 수백만 번에 한번씩 버그가 발생하기도 한다. 그런 문제를 그저 일시적인 문제라고 여겨지는 경우가 많다. 
* 일시적인 문제란 존재 하지 않는다. 이런 문제를 계속 무시하면 잘못된 코드위에 계속 잘못된 코드가 쌓이게 된다. 
> 권장사항 : 시스템 실패를 '일시적인' 오류로 치부하지 마라. 

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 
* 스레드 환경을 타지 않은 POJO를 만들어 테스트를 하라. 
* POJO는 스레드를 모른다. 따라서 스레드 환경에 구애받지 않고 테스트가 가능하다.
> 권장사항 : 스레드 환경 밖에서 생기는 버그와 안에서 생기는 버그를 동시에 테스트 하지 마라. 먼저 환경 밖에서 하는 것부터 테스트를 돌려라. 

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
* 다중 스레드 코드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라. 
  * 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다. 
  * 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다. 
  * 테스트 코드를 빨리, 또는 천천히 다양한 속도로 돌려 본다. 
  * 반복 테스트가 가능하도록 테스트 케이스를 작성한다. 

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라. 
* 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다. 
* 그래서 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다. 
* 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려한다. 
* 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민한다.

### 프로세서 수보다 많은 스레드를 돌려봐라
* 시스템이 스레드를 스와핑(swapping)할 때도 문제가 발생한다. 
* 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌려봐야한다. 
* 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다. 

### 다른 플랫폼에서  돌려보라 
* OS 마다 스레드를 처리하는 정책이 달라 결과다 달라질 수 있다. 
* 따라서 코드가 돌아갈 가능성있는 플랫폼 전부에서 테스트를 수행해야 마땅하다. 

### 코드에 보조코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키게 해보라. 
* 스레드 코드는 오류를 찾기 쉽지 않다. 버그가 발생한다고 해다 그 확률은 극히 드물다. 
* 그런 버그를 잡기 위해서는 보조코드를 추가해 코드가 실행되는 순서를 바꿔준다. 
* Object.wait(), Object.sleep(), Object.priority() 등 메서드를 추가해 코드를 다양한 순서로 실행한다. 
* 코드에 보조 코드를 추가하는 방법은 두 가지다. (직접구현하기, 자동화)

> 직접 구현하기 
* 코드에다 지접 wait(), sleep(), yield(), priority() 함수를 추가한다. 특별히 까다로운 코드를 테스트할 때  적합하다. 
```java
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield(); //테스트를 위해 추가됐다. 
        updateHasNext();
        return url;
    }    
    return url;
}
```
yield()를 삽입하면 코드가 실행 경보를 바꾼다. 그래서 이전에 실패하지 않은 코드가 실패할 가능성을 열어 준다. 하지만 이 방법에는 여러 가지 문제가 있다. 
* 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다. 
* 어떤 함수를 어디서 호출해야 적당한지 어떻게 알까? 
* 배포 환경에 보조코드를 그대로 남겨두면 프로그램 성능이 떨어진다. 
* 무작위적이다. 오류가 드러날지 아닐지 모른다.

> 배포환경이 아니라 테스트 환경에서 보조코드를 실행할 방법이 필요하다.    
> 실행 할 때마다 설정을 바꿔줄 방법도 필요하다.


> 자동화
* 보조 코드를 자동으로 추가하려면 AOF(Asfect-Oriented Framework), CGLIB, ASM 등 동구를 사용한다.
```java
public class ThreadJigglePoint {
    public static void jiggle() {
        
    }
}

public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJigglePoint.jiggle();
        String ulr = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return url;
}
```

* ThreadJigglePoint.jiggle(); 호출은 무작위로 sleep이나 yield를 호출한다. 
* ThreadJigglePoint 클래스를 배포 환경에서는 메서드를 공백으로 두고 테스트 환경에서만 구현하는 방식으로 할 수 있다. 
* 이렇게 무작위로 실행 하도록 코드를 수천번 실행해서 오류가 안난다면 최선을 다했다고 볼 수 있다. 

> 14장 점진적 개선부터 16장 SefialDate 리팩터링까지는 실제 기존소스를 보고 하나씩 리팩토링하는 과정이 담겨져있다.   
> 그 과정을 다 정리해서 기술하기에는 무리가있어 내가 보기에 여기서 배워야 할 부분이 무엇인지를 요약하는 정도만 정리했다.   
> 여기서 중점적으로 본것은 아래와 같다. 
> 1. 리팩토링은 한까번에 변경 보다는 점진적으로 하나씩 변경하는것이 좋다. (에러 발생 찾기 쉬움, 아키텍쳐 변경 쉬움)
> 2. 실제로 내가 하는 방식과 실제 전문가들이 하는 리팩토링의 차이

## 점진적인 개선
* 첫 버전이던 Boolean 인수만 지원하던 초기 버전에서 String과 Integer 인수 유형을 추가하면서 부터 재앙이 시작됐다.
* 새 인수 유형 추가 시 주요 지점에 유영 추가 마다 코드를 추가해야 하는 상황 발생 -> 리팩토링 
  * 인수 유형 HashMap 선택 하기 위해 스키마 요소의 구문을 분석하는 부분 
  * 명령행 인수에서 인수 유형을 분석해 진짜 유형으로 변환한다. 
  * getXXX 메서드를 구현해 호출자에게 진짜 유형을 반환한다. 
  * *인수 유형은 다양하지만 유사한 메서드 발생 시 클래스 하나로 통합하는게 적합하다.*
> 그래서 탄생한게 ArumentMarshaler 인터페이스 개념이다.

* TDD를 통해 점진적으로 개선해 나간다. 
* 기존방식 -> 공통적인 부분 클래스 통합 -> 추상 클래스화 -> 인터페이스

* 개선을 할 때는 구조를 크게 뒤집는건 좋지 않다.
* TDD는 시스템이 돌아가야하는 원칙이 있어서 TDD로 하는게 좋다. 즉, 변경전과 똑같이 돌아가야 한다는것이다. 


## JUit 들여다 보기 
* 접두어있는 변수명 변경 
* 의도파악을 위한 조건문 캡슐화
* 의도 파악을 위한 변수명 변경 

## SerialDate 리팩터링
* import 문 줄이기
* javadoc 여러 언어 사용
* SerialDate라는 용어 부적합
* MothConstansts(달 정의) -> enum 클래스로 변경
* 변수 사용에 대한 클래스 이동
* 부모-자식 클래스간의 경계
* aggregate
* enum의 활용에 따른 버그 및 예외처리 최소화 
